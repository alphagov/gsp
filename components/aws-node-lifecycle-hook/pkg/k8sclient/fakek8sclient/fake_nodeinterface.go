// Code generated by counterfeiter. DO NOT EDIT.
package fakek8sclient

import (
	"sync"

	"github.com/alphagov/gsp/components/aws-node-lifecycle-hook/pkg/k8sclient"
	v1 "k8s.io/api/core/v1"
	v1a "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
)

type FakeNodeInterface struct {
	CreateStub        func(*v1.Node) (*v1.Node, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 *v1.Node
	}
	createReturns struct {
		result1 *v1.Node
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *v1.Node
		result2 error
	}
	DeleteStub        func(string, *v1a.DeleteOptions) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
		arg2 *v1a.DeleteOptions
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteCollectionStub        func(*v1a.DeleteOptions, v1a.ListOptions) error
	deleteCollectionMutex       sync.RWMutex
	deleteCollectionArgsForCall []struct {
		arg1 *v1a.DeleteOptions
		arg2 v1a.ListOptions
	}
	deleteCollectionReturns struct {
		result1 error
	}
	deleteCollectionReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(string, v1a.GetOptions) (*v1.Node, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
		arg2 v1a.GetOptions
	}
	getReturns struct {
		result1 *v1.Node
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *v1.Node
		result2 error
	}
	ListStub        func(v1a.ListOptions) (*v1.NodeList, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 v1a.ListOptions
	}
	listReturns struct {
		result1 *v1.NodeList
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 *v1.NodeList
		result2 error
	}
	PatchStub        func(string, types.PatchType, []byte, ...string) (*v1.Node, error)
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		arg1 string
		arg2 types.PatchType
		arg3 []byte
		arg4 []string
	}
	patchReturns struct {
		result1 *v1.Node
		result2 error
	}
	patchReturnsOnCall map[int]struct {
		result1 *v1.Node
		result2 error
	}
	PatchStatusStub        func(string, []byte) (*v1.Node, error)
	patchStatusMutex       sync.RWMutex
	patchStatusArgsForCall []struct {
		arg1 string
		arg2 []byte
	}
	patchStatusReturns struct {
		result1 *v1.Node
		result2 error
	}
	patchStatusReturnsOnCall map[int]struct {
		result1 *v1.Node
		result2 error
	}
	UpdateStub        func(*v1.Node) (*v1.Node, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 *v1.Node
	}
	updateReturns struct {
		result1 *v1.Node
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *v1.Node
		result2 error
	}
	UpdateStatusStub        func(*v1.Node) (*v1.Node, error)
	updateStatusMutex       sync.RWMutex
	updateStatusArgsForCall []struct {
		arg1 *v1.Node
	}
	updateStatusReturns struct {
		result1 *v1.Node
		result2 error
	}
	updateStatusReturnsOnCall map[int]struct {
		result1 *v1.Node
		result2 error
	}
	WatchStub        func(v1a.ListOptions) (watch.Interface, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		arg1 v1a.ListOptions
	}
	watchReturns struct {
		result1 watch.Interface
		result2 error
	}
	watchReturnsOnCall map[int]struct {
		result1 watch.Interface
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNodeInterface) Create(arg1 *v1.Node) (*v1.Node, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 *v1.Node
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeInterface) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeNodeInterface) CreateCalls(stub func(*v1.Node) (*v1.Node, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeNodeInterface) CreateArgsForCall(i int) *v1.Node {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNodeInterface) CreateReturns(result1 *v1.Node, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) CreateReturnsOnCall(i int, result1 *v1.Node, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *v1.Node
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) Delete(arg1 string, arg2 *v1a.DeleteOptions) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
		arg2 *v1a.DeleteOptions
	}{arg1, arg2})
	fake.recordInvocation("Delete", []interface{}{arg1, arg2})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1
}

func (fake *FakeNodeInterface) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeNodeInterface) DeleteCalls(stub func(string, *v1a.DeleteOptions) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeNodeInterface) DeleteArgsForCall(i int) (string, *v1a.DeleteOptions) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNodeInterface) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInterface) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInterface) DeleteCollection(arg1 *v1a.DeleteOptions, arg2 v1a.ListOptions) error {
	fake.deleteCollectionMutex.Lock()
	ret, specificReturn := fake.deleteCollectionReturnsOnCall[len(fake.deleteCollectionArgsForCall)]
	fake.deleteCollectionArgsForCall = append(fake.deleteCollectionArgsForCall, struct {
		arg1 *v1a.DeleteOptions
		arg2 v1a.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("DeleteCollection", []interface{}{arg1, arg2})
	fake.deleteCollectionMutex.Unlock()
	if fake.DeleteCollectionStub != nil {
		return fake.DeleteCollectionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteCollectionReturns
	return fakeReturns.result1
}

func (fake *FakeNodeInterface) DeleteCollectionCallCount() int {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return len(fake.deleteCollectionArgsForCall)
}

func (fake *FakeNodeInterface) DeleteCollectionCalls(stub func(*v1a.DeleteOptions, v1a.ListOptions) error) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = stub
}

func (fake *FakeNodeInterface) DeleteCollectionArgsForCall(i int) (*v1a.DeleteOptions, v1a.ListOptions) {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	argsForCall := fake.deleteCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNodeInterface) DeleteCollectionReturns(result1 error) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	fake.deleteCollectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInterface) DeleteCollectionReturnsOnCall(i int, result1 error) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	if fake.deleteCollectionReturnsOnCall == nil {
		fake.deleteCollectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCollectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNodeInterface) Get(arg1 string, arg2 v1a.GetOptions) (*v1.Node, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
		arg2 v1a.GetOptions
	}{arg1, arg2})
	fake.recordInvocation("Get", []interface{}{arg1, arg2})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeNodeInterface) GetCalls(stub func(string, v1a.GetOptions) (*v1.Node, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeNodeInterface) GetArgsForCall(i int) (string, v1a.GetOptions) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNodeInterface) GetReturns(result1 *v1.Node, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) GetReturnsOnCall(i int, result1 *v1.Node, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *v1.Node
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) List(arg1 v1a.ListOptions) (*v1.NodeList, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 v1a.ListOptions
	}{arg1})
	fake.recordInvocation("List", []interface{}{arg1})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeInterface) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeNodeInterface) ListCalls(stub func(v1a.ListOptions) (*v1.NodeList, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeNodeInterface) ListArgsForCall(i int) v1a.ListOptions {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNodeInterface) ListReturns(result1 *v1.NodeList, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 *v1.NodeList
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) ListReturnsOnCall(i int, result1 *v1.NodeList, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 *v1.NodeList
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 *v1.NodeList
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) Patch(arg1 string, arg2 types.PatchType, arg3 []byte, arg4 ...string) (*v1.Node, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		arg1 string
		arg2 types.PatchType
		arg3 []byte
		arg4 []string
	}{arg1, arg2, arg3Copy, arg4})
	fake.recordInvocation("Patch", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.patchMutex.Unlock()
	if fake.PatchStub != nil {
		return fake.PatchStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.patchReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeInterface) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *FakeNodeInterface) PatchCalls(stub func(string, types.PatchType, []byte, ...string) (*v1.Node, error)) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = stub
}

func (fake *FakeNodeInterface) PatchArgsForCall(i int) (string, types.PatchType, []byte, []string) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	argsForCall := fake.patchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeNodeInterface) PatchReturns(result1 *v1.Node, result2 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) PatchReturnsOnCall(i int, result1 *v1.Node, result2 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 *v1.Node
			result2 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) PatchStatus(arg1 string, arg2 []byte) (*v1.Node, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.patchStatusMutex.Lock()
	ret, specificReturn := fake.patchStatusReturnsOnCall[len(fake.patchStatusArgsForCall)]
	fake.patchStatusArgsForCall = append(fake.patchStatusArgsForCall, struct {
		arg1 string
		arg2 []byte
	}{arg1, arg2Copy})
	fake.recordInvocation("PatchStatus", []interface{}{arg1, arg2Copy})
	fake.patchStatusMutex.Unlock()
	if fake.PatchStatusStub != nil {
		return fake.PatchStatusStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.patchStatusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeInterface) PatchStatusCallCount() int {
	fake.patchStatusMutex.RLock()
	defer fake.patchStatusMutex.RUnlock()
	return len(fake.patchStatusArgsForCall)
}

func (fake *FakeNodeInterface) PatchStatusCalls(stub func(string, []byte) (*v1.Node, error)) {
	fake.patchStatusMutex.Lock()
	defer fake.patchStatusMutex.Unlock()
	fake.PatchStatusStub = stub
}

func (fake *FakeNodeInterface) PatchStatusArgsForCall(i int) (string, []byte) {
	fake.patchStatusMutex.RLock()
	defer fake.patchStatusMutex.RUnlock()
	argsForCall := fake.patchStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNodeInterface) PatchStatusReturns(result1 *v1.Node, result2 error) {
	fake.patchStatusMutex.Lock()
	defer fake.patchStatusMutex.Unlock()
	fake.PatchStatusStub = nil
	fake.patchStatusReturns = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) PatchStatusReturnsOnCall(i int, result1 *v1.Node, result2 error) {
	fake.patchStatusMutex.Lock()
	defer fake.patchStatusMutex.Unlock()
	fake.PatchStatusStub = nil
	if fake.patchStatusReturnsOnCall == nil {
		fake.patchStatusReturnsOnCall = make(map[int]struct {
			result1 *v1.Node
			result2 error
		})
	}
	fake.patchStatusReturnsOnCall[i] = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) Update(arg1 *v1.Node) (*v1.Node, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 *v1.Node
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeInterface) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeNodeInterface) UpdateCalls(stub func(*v1.Node) (*v1.Node, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeNodeInterface) UpdateArgsForCall(i int) *v1.Node {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNodeInterface) UpdateReturns(result1 *v1.Node, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) UpdateReturnsOnCall(i int, result1 *v1.Node, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *v1.Node
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) UpdateStatus(arg1 *v1.Node) (*v1.Node, error) {
	fake.updateStatusMutex.Lock()
	ret, specificReturn := fake.updateStatusReturnsOnCall[len(fake.updateStatusArgsForCall)]
	fake.updateStatusArgsForCall = append(fake.updateStatusArgsForCall, struct {
		arg1 *v1.Node
	}{arg1})
	fake.recordInvocation("UpdateStatus", []interface{}{arg1})
	fake.updateStatusMutex.Unlock()
	if fake.UpdateStatusStub != nil {
		return fake.UpdateStatusStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateStatusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeInterface) UpdateStatusCallCount() int {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return len(fake.updateStatusArgsForCall)
}

func (fake *FakeNodeInterface) UpdateStatusCalls(stub func(*v1.Node) (*v1.Node, error)) {
	fake.updateStatusMutex.Lock()
	defer fake.updateStatusMutex.Unlock()
	fake.UpdateStatusStub = stub
}

func (fake *FakeNodeInterface) UpdateStatusArgsForCall(i int) *v1.Node {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	argsForCall := fake.updateStatusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNodeInterface) UpdateStatusReturns(result1 *v1.Node, result2 error) {
	fake.updateStatusMutex.Lock()
	defer fake.updateStatusMutex.Unlock()
	fake.UpdateStatusStub = nil
	fake.updateStatusReturns = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) UpdateStatusReturnsOnCall(i int, result1 *v1.Node, result2 error) {
	fake.updateStatusMutex.Lock()
	defer fake.updateStatusMutex.Unlock()
	fake.UpdateStatusStub = nil
	if fake.updateStatusReturnsOnCall == nil {
		fake.updateStatusReturnsOnCall = make(map[int]struct {
			result1 *v1.Node
			result2 error
		})
	}
	fake.updateStatusReturnsOnCall[i] = struct {
		result1 *v1.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) Watch(arg1 v1a.ListOptions) (watch.Interface, error) {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		arg1 v1a.ListOptions
	}{arg1})
	fake.recordInvocation("Watch", []interface{}{arg1})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.watchReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNodeInterface) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeNodeInterface) WatchCalls(stub func(v1a.ListOptions) (watch.Interface, error)) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = stub
}

func (fake *FakeNodeInterface) WatchArgsForCall(i int) v1a.ListOptions {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	argsForCall := fake.watchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNodeInterface) WatchReturns(result1 watch.Interface, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) WatchReturnsOnCall(i int, result1 watch.Interface, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 watch.Interface
			result2 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeNodeInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	fake.patchStatusMutex.RLock()
	defer fake.patchStatusMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNodeInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ k8sclient.NodeInterface = new(FakeNodeInterface)
